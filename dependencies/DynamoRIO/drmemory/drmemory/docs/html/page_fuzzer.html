<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Dr. Memory: Fuzz Testing Mode</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Dr. Memory
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_fuzzer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Fuzz Testing Mode </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Dr. Memory provides a fuzz testing mode that repeatedly executes one function in the target application, mutating the value of one argument before each iteration. Fuzz mode is configured using the runtime option <code>-fuzz_target</code>, and the mutator is configured using the option <code>-fuzz_mutator</code>. Both of these options require the user to supply a descriptor to define the behavior of the feature. An overview of each descriptor format is provided in the <a class="el" href="page_options.html">Dr. Memory Runtime Option Reference</a> (and the command line help text). Many of these options require a more complete explanation, which is provided in the following sections.</p>
<h1><a class="anchor" id="sec_fuzzer_target"></a>
Fuzzer Target</h1>
<p>The fuzzer is capable of testing one target function on potentially multiple concurrent threads. Specify the target function on the Dr. Memory command line using the value of option <code>-fuzz_target</code> (see <a class="el" href="page_options.html">Dr. Memory Runtime Option Reference</a>). To find the target function at runtime, the fuzzer needs to know either its symbol name, or its offset from the start of the module. In addition, to repeatedly execute the target function, the fuzzer needs to know (a) how many arguments it has, (b) which argument should be fuzzed, and (c) which argument specifies the size of the fuzzed argument. For example, to fuzz the following C function in the "munger" module: </p>
<pre class="fragment">void munge_buffer(uint8_t *buffer, size_t size);
</pre><p>you would specify the following command-line option to <code>drmemory:</code> </p>
<pre class="fragment">-fuzz_target 'munger!munge_buffer|2|0|1|0'
</pre><p>where the final "0" indicates to fuzz the target indefinitely (or until the mutator is exhausted, which is rarely possible). Note that in Windows the module name must be include its extension (optional on linux): </p>
<pre class="fragment">-fuzz_target 'munger.exe!munge_buffer|2|0|1|0'
</pre><p>In bash, use single-quotes to avoid special behaviors of the '!' and '|' characters.</p>
<h1><a class="anchor" id="sec_cpp_targets"></a>
C++ Targets</h1>
<p>Specifying C function targets is much simpler than C++ targets because the symbol name is the plain text name of the function, and the calling convention is almost always the default. For C++ functions, the mangled or de-mangled name is required. On Unix the fuzzer only accepts mangled names, while on Windows it accepts both the mangled and de-mangled names (for the former, use Windows-only option <code>-fuzz_mangled_names</code>). To fuzz the following function on Unix (compiling the app with 32-bit gcc): </p>
<pre class="fragment">void CryptoMagic::MungeBuffer(unsigned int *buffer, size_t size);
</pre><p>you would specify the following option to <code>drmemory:</code> </p>
<pre class="fragment">-fuzz_target 'crypto!_ZN13CryptoMagic8MungeBufferEPjj|2|0|1|0'
</pre><h1><a class="anchor" id="sec_calling_conventions"></a>
Calling Conventions</h1>
<p>The fuzzer's default calling convention is <code>cdecl</code> on 32-bit x86 platforms, <code>AMD64</code> on 64-bit *nix, and <code>Microsoft</code> <code>x64</code> for Visual Studio 64-bit applications. Use the optional last field of option <code>-fuzz_target</code> to specify a different calling convention. For example, to fuzz the following function on Windows (compiling the app with Visual Studio): </p>
<pre class="fragment">void CryptoMagic::MungeBuffer(unsigned int *buffer, size_t size);
</pre><p>you would specify: </p>
<pre class="fragment">-fuzz_target 'crypto.exe!?MungeBuffer-CryptoMagic&amp;ndash;QAEXPAII-Z|3|1|2|0|6'
</pre><p>The calling convention <code>6</code> specifies <code>thiscall</code> (as defined by the enum <code>drwrap_callconv_t</code> in the DynamoRIO header file <code>drwrap.h</code>). Since the <code>MungeBuffer()</code> method is a non-static class member, the first argument is reserved by the compiler for the <code>this</code> pointer. Accordingly, the argument indexes in the descriptor (fields 3 and 4, <code>"|1|2|"</code>) have been adjusted to account for the implicit first argument, along with the argument count (field 2, <code>"|3|"</code>). Notice that the <code>'@'</code> characters in the symbol have been escaped with <code>'-'</code> for compatibility with the Dr. Memory command-line processor.</p>
<h1><a class="anchor" id="sec_mutator_alg_and_unit"></a>
Mutator Algorithms and Units</h1>
<p>The fuzzer provides two algorithms for mutating the fuzzed argument, ordered and random, and each algorithm can operate in terms of bit-flips or integers. The latter option is referred to as the "unit" of mutation. The behavior of these two mutator options can be easily seen in the following example, where the app's original argument value is all zero (at left), and each successive value reflects one mutation: </p>
<pre class="fragment">Ordered bit-flip: 0x00000000 =&gt; 0x00000001 =&gt; 0x00000100 =&gt; 0x00010000 =&gt; 0x01000000
Random bit-flip:  0x00000000 =&gt; 0x00200000 =&gt; 0x00008000 =&gt; 0x00000004 =&gt; 0x00002000
Ordered numeric:  0x00000000 =&gt; 0x00000001 =&gt; 0x00000002 =&gt; 0x00000003 =&gt; 0x00000004
Random numeric:   0x00000000 =&gt; 0x7abcbb5e =&gt; 0xc6f15f41 =&gt; 0xaebd59a2 =&gt; 0xc375f0ae
</pre><p>Notice that the bit-flip unit does not flip bits in a lexical sequence, even when the ordered algorithm is selected. Instead, it distributes the flips across the bytes first, and secondarily across the bits of each byte. The goal is to improve mutator coverage for very large input buffers, especially when the sparsity option is used (see below). The following sequence illustrates how ordered bit-flip distributes all permutations of a single flip across a 2-byte buffer: </p>
<pre class="fragment">0x0000 =&gt; 0x0001 =&gt; 0x0100 =&gt; 0x0002 =&gt; 0x0200 =&gt; 0x0004 =&gt; 0x0400 =&gt; 0x0008 =&gt; 0x0800
       =&gt; 0x0010 =&gt; 0x1000 =&gt; 0x0020 =&gt; 0x0200 =&gt; 0x0040 =&gt; 0x4000 =&gt; 0x0080 =&gt; 0x8000
</pre><p>After completing all flips of a single bit, the mutator will proceed to flip two bits: </p>
<pre class="fragment">0x0000 =&gt; 0x0101 =&gt; 0x0003 =&gt; 0x0201 =&gt; 0x0005 =&gt; 0x0401 =&gt; 0x0009 =&gt; 0x0801 =&gt; 0x0011
       =&gt; 0x1001 =&gt; 0x0021 =&gt; 0x2001 =&gt; 0x0041 =&gt; 0x4001 =&gt; 0x0081 =&gt; 0x8001 =&gt; 0x0006
</pre><h1><a class="anchor" id="sec_mutator_rand_gen"></a>
Mutator Random Number Generator</h1>
<p>The mutator uses a stateless xorshift algorithm for all of its randomized decisions (see xorshift64star on <a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>). For randomized bit-flip, the mutator selects which bits to flip using the Fisher-Yates shuffle (<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle</a>).</p>
<p>To repeat a fuzz test using the exact same sequence of values for the fuzz target function, specify the same random seed as the original fuzz test using the mutator descriptor's optional last field; for example: </p>
<pre class="fragment">-fuzz_mutator "r|b|r|1|0x17a3cd8648a6ab1f"
</pre><p>To avoid repeating the exact same fuzz test when using the random algorithm, and pass flag <code>'t'</code> in the mutator descriptor (field 3 in option <code>-fuzz_mutator</code>) to seed the random algorithm with the system clock time. The seed will be reported in the log and in the console output (when enabled) for future reference, e.g., to repeat that fuzz test.</p>
<h1><a class="anchor" id="sec_mutator_proximity"></a>
Mutator "Proximity" via Reset Option</h1>
<p>Although the fuzzer executes the target function as rapidly as possible on the given hardware (by redirecting execution directly from the function return back into the function entry point), the number of possible values for the fuzzed argument usually makes it impossible to try all permutations. In many scenarios, the most interesting app functionality can be reached using argument values that are very similar to a "correct" or "typical" input value. For this reason, the fuzzer takes the original argument value passed by the application as a starting point for mutation. To explore input values that are most similar to the app's original input value, use flag <code>'r'</code> in the mutator descriptor (field 3 in option <code>-fuzz_mutator</code>) to reset the argument to the app's original value before each mutation. Omitting this flag will cause the successive mutations to accumulate. For example, a bit-flipping mutator using the reset option might generate the following sequence on a 4-byte buffer, where the first value is the app's original argument value, and each successive value reflects one mutation (marked with overstrike): </p>
<pre class="fragment">                      __          __          __          __
0x01020304 =&gt; 0x01020305 =&gt; 0x01020204 =&gt; 0x01030304 =&gt; 0x00020304
</pre><p>But the same mutator without the reset option would generate this sequence: </p>
<pre class="fragment">                      __          ____        ______      ________
0x01020304 =&gt; 0x01020305 =&gt; 0x01020205 =&gt; 0x01030205 =&gt; 0x00030205
</pre><p>As you can see, the mutated value remains very similar to the original input when using the reset option, but quickly diverges without it.</p>
<h1><a class="anchor" id="sec_mutator_sparsity"></a>
Mutator Sparsity</h1>
<p>For many target functions, the reset option generates inputs that are too similar, causing the majority of inputs to be redundant&ndash;yet completely random input may also be ineffective. To generate a moderately diverse range of input values, the sparsity can be specified in the mutator descriptor (field 4 in option <code>-fuzz_mutator</code>). The term "sparsity" refers to the coverage of the space of possible input values, where a sparsity of 1 indicates to first cover all values reachable by a single bit-flip of the app's original argument value, then cover all values reachable by 2 bit-flips, and so on. By increasing the sparsity, the mutator will reduce the number of permutations it generates at each degree of bit flipping. The following table provides an example of sparsity one, given a 4-byte input buffer: </p>
<pre class="fragment">Bit-Flip Degree   Total Mutator Values
              1                     32
              2                    992
              3                  29760
</pre><p>By increasing the sparsity to just 4, the number of mutator values at each degree of bit flipping is greatly reduced: </p>
<pre class="fragment">Bit-Flip Degree   Total Mutator Values
              1                      8
              2                    248
              3                   7440
</pre><p>This second approach balances the diversity of input values with the proximity of each generated input to the app's original argument value. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  Dr. Memory version 1.9.0 --- Mon Oct 5 2015 18:31:40 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
